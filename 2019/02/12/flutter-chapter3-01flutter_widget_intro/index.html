<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Widget简介概念在前面的介绍中，我们知道Flutter中几乎所有的对象都是一个Widget，与原生开发中“控件”不同的是，Flutter中的widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于应用主题数据传递的Theme等等。而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时，">
<meta name="keywords" content="flutter">
<meta property="og:type" content="article">
<meta property="og:title" content="第三章 - 01Widget简介">
<meta property="og:url" content="http://yoursite.com/2019/02/12/flutter-chapter3-01flutter_widget_intro/index.html">
<meta property="og:site_name" content="小沈曰">
<meta property="og:description" content="Widget简介概念在前面的介绍中，我们知道Flutter中几乎所有的对象都是一个Widget，与原生开发中“控件”不同的是，Flutter中的widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于应用主题数据传递的Theme等等。而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/Screenshot_1535019164.png">
<meta property="og:image" content="https://flutterchina.club/tutorials/interactive/images/tapbox-active-state.png">
<meta property="og:image" content="https://flutterchina.club/tutorials/interactive/images/tapbox-inactive-state.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180824181958838.png">
<meta property="og:updated_time" content="2019-04-13T08:33:09.290Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第三章 - 01Widget简介">
<meta name="twitter:description" content="Widget简介概念在前面的介绍中，我们知道Flutter中几乎所有的对象都是一个Widget，与原生开发中“控件”不同的是，Flutter中的widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于应用主题数据传递的Theme等等。而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时，">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/Screenshot_1535019164.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/02/12/flutter-chapter3-01flutter_widget_intro/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>第三章 - 01Widget简介 | 小沈曰</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小沈曰</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">自由不是你想做什么就做什么，而是你不想做什么就可以不做什么。</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/12/flutter-chapter3-01flutter_widget_intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="st">
      <meta itemprop="description" content="人生滋味，情最浓；世间繁华，淡最真。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小沈曰">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">第三章 - 01Widget简介

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-12 20:19:18" itemprop="dateCreated datePublished" datetime="2019-02-12T20:19:18+08:00">2019-02-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-04-13 16:33:09" itemprop="dateModified" datetime="2019-04-13T16:33:09+08:00">2019-04-13</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/flutter/" itemprop="url" rel="index"><span itemprop="name">flutter</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Widget简介"><a href="#Widget简介" class="headerlink" title="Widget简介"></a>Widget简介</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在前面的介绍中，我们知道Flutter中几乎所有的对象都是一个Widget，与原生开发中“控件”不同的是，Flutter中的widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> widget、用于应用主题数据传递的<code>Theme</code>等等。而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时，我们可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是widget，只是在不同场景的不同表述而已。由于Flutter主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为widget就是一个控件，不必纠结于概念。</p>
<h3 id="Widget与Element"><a href="#Widget与Element" class="headerlink" title="Widget与Element"></a>Widget与Element</h3><p>在Flutter中，Widget的功能是“描述一个UI元素的配置数据”，它就是说，Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而只是显示元素的一个配置数据。实际上，Flutter中真正代表屏幕上显示元素的类是<code>Element</code>，也就是说Widget只是描述<code>Element</code>的一个配置，有关<code>Element</code>的详细介绍我们将在本书后面的高级部分深入介绍，读者现在只需要知道，Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个<code>Element</code>，这是因为同一个Widget对象可以被添加到UI树的不同部分，而真正渲染时，UI树的每一个Widget节点都会对应一个<code>Element</code>对象。总结一下：</p>
<ul>
<li>Widget实际上就是Element的配置数据，Widget树实际上是一个配置树，而真正的UI渲染树是由Element构成；不过，由于Element是通过Widget生成，所以它们之间有对应关系，所以在大多数场景，我们可以宽泛地认为Widget树就是指UI控件树或UI渲染树。</li>
<li>一个Widget对象可以对应多个Element对象。这很好理解，根据同一份配置（Widget），可以创建多个实例（Element）。</li>
</ul>
<p>读者应该将这两点牢记在心中。</p>
<h3 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h3><p>我们先来看一下Widget类的声明：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@immutable</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line">  <span class="keyword">final</span> Key key;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="string">'<span class="subst">$runtimeType</span>'</span> : <span class="string">'<span class="subst">$runtimeType</span>-<span class="subst">$key</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Widget</code>类继承自<code>DiagnosticableTree</code>，<code>DiagnosticableTree</code>即“诊断树”，主要作用是提供调试信息。</li>
<li><code>Key</code>: 这个<code>key</code>属性类似于React/Vue中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的widget，决定的条件在<code>canUpdate()</code>方法中。</li>
<li><code>createElement()</code>：正如前文所述“一个Widget可以对应多个<code>Element</code>”；Flutter Framework在构建UI树时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是Flutter Framework隐式调用的，在我们开发过程中基本不会调用到。</li>
<li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li>
<li><code>canUpdate(...)</code>是一个静态方法，它主要用于在Widget树重新<code>build</code>时复用旧的widget，其实具体来说，应该是：是否用新的Widget对象去更新旧UI树上所对应的<code>Element</code>对象的配置；通过其源码我们可以看到，只要<code>newWidget</code>与<code>oldWidget</code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>newWidget</code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code>。</li>
</ul>
<p>有关Key和Widget复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为Widget显式添加key的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数。本书后面的示例中，我们只在构建列表项UI时会显式指定Key。</p>
<p>另外<code>Widget</code>类本身是一个抽象类，其中最核心的就是定义了<code>createElement()</code>接口，在Flutter开发中，我们一般都不用直接继承<code>Widget</code>类来实现Widget，相反，我们通常会通过继承<code>StatelessWidget</code>和<code>StatefulWidget</code>来间接继承<code>Widget</code>类来实现，而<code>StatelessWidget</code>和<code>StatefulWidget</code>都是直接继承自<code>Widget</code>类，而这两个类也正是Flutter中非常重要的两个抽象类，它们引入了两种Widget模型，接下来我们将重点介绍一下这两个类。</p>
<h2 id="Stateless-Widget"><a href="#Stateless-Widget" class="headerlink" title="Stateless Widget"></a>Stateless Widget</h2><p>在之前的章节中，我们已经简单介绍过StatelessWidget，StatelessWidget相对比较简单，它继承自<code>Widget</code>，重写了<code>createElement()</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">StatelessElement createElement() =&gt; <span class="keyword">new</span> StatelessElement(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p><code>StatelessElement</code> 间接继承自<code>Element</code>类，与StatelessWidget相对应（作为其配置数据）。</p>
<p>StatelessWidget用于不需要维护状态的场景，它通常在<code>build</code>方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。我们看一个简单的例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Echo</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Echo(&#123;</span><br><span class="line">    Key key,  </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.text,</span><br><span class="line">    <span class="keyword">this</span>.backgroundColor:Colors.grey,</span><br><span class="line">  &#125;):<span class="keyword">super</span>(key:key);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line">  <span class="keyword">final</span> Color backgroundColor;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Container(</span><br><span class="line">        color: backgroundColor,</span><br><span class="line">        child: Text(text),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，实现了一个回显字符串的<code>Echo</code> widget。</p>
<blockquote>
<p>按照惯例，widget的构造函数应使用命名参数，命名参数中的必要参数要添加@required标注，这样有利于静态代码分析器进行检查，另外，在继承widget时，第一个参数通常应该是<code>Key</code>，如果接受子widget的child参数，那么通常应该将它放在参数列表的最后。同样是按照惯例，widget的属性应被声明为<code>final</code>，防止被意外改变。</p>
</blockquote>
<p>然后我们可以通过如下方式使用它：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Echo(text: <span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/Screenshot_1535019164.png" alt="Screenshot_1535019164"></p>
<h2 id="Stateful-Widget"><a href="#Stateful-Widget" class="headerlink" title="Stateful Widget"></a>Stateful Widget</h2><p>和StatelessWidget一样，StatefulWidget也是继承自widget类，并重写了<code>createElement()</code>方法，不同的是返回的<code>Element</code> 对象并不相同；另外StatefulWidget类中添加了一个新的接口<code>createState()</code>，下面我们看看StatefulWidget的类定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; <span class="keyword">new</span> StatefulElement(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  State createState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>StatefulElement</code> 间接继承自<code>Element</code>类，与StatefulWidget相对应（作为其配置数据）。<code>StatefulElement</code>中可能会多次调用<code>createState()</code>来创建状态(State)对象。</p>
</li>
<li><p><code>createState()</code> 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个<code>StatefulElement</code>对应一个State实例。</p>
<blockquote>
<p>在本书中经常会出现“树“的概念，在不同的场景可能指不同的意思，在说“widget树”时它可以指widget结构树，但由于widget与Element有对应关系（一可能对多），在有些场景（Flutter的SDK文档中）也代指“UI树”的意思。而在stateful widget中，State对象也和<code>StatefulElement</code>具有对应关系（一对一），所以在Flutter的SDK文档中，可以经常看到“从树中移除State对象”或“插入State对象到树中”这样的描述。其实，无论哪种描述，其意思都是在描述“一棵构成用户界面的节点元素的树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”，因此，本书中出现的各种“树”，如果没有特别说明，读者都可抽象的认为它是“一棵构成用户界面的节点元素的树”。</p>
</blockquote>
</li>
</ul>
<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存的状态信息可以：</p>
<ol>
<li>在widget build时可以被同步读取。</li>
<li>在widget生命周期中可以被改变，当State被改变时，可以手动调用其<code>setState()</code>方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其<code>build</code>方法重新构建widget树，从而达到更新UI的目的。</li>
</ol>
<p>State中有两个常用属性：</p>
<ol>
<li><p><code>widget</code>，它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联并非永久的，因为在应用声明周期中，UI树上的某一个节点的widget实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，Flutter framework会动态设置State.widget为新的widget实例。</p>
</li>
<li><p><code>context</code>，它是<code>BuildContext</code>类的一个实例，表示构建widget的上下文，它是操作widget在树中位置的一个句柄，它包含了一些查找、遍历当前Widget树的一些方法。每一个widget都有一个自己的context对象。</p>
<blockquote>
<p>对于<code>BuildContext</code>读者现在可以先作了解，随着本书后面内容的展开，也会用到Context的一些方法，读者可以通过具体的场景对其有个直观的认识。关于<code>BuildContext</code>更多的内容，我们也将在后面高级部分再深入介绍。</p>
</blockquote>
</li>
</ol>
<h4 id="State生命周期"><a href="#State生命周期" class="headerlink" title="State生命周期"></a>State生命周期</h4><p>理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下State的生命周期。在接下来的示例中，我们实现一个计数器widget，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> CounterWidget(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="keyword">this</span>.initValue: <span class="number">0</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> initValue;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterWidgetState createState() =&gt; <span class="keyword">new</span> _CounterWidgetState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CounterWidget</code>接收一个<code>initValue</code>整形参数，它表示计数器的初始值。下面我们看一下State的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterWidget</span>&gt; </span>&#123;  </span><br><span class="line">  <span class="built_in">int</span> _counter;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">//初始化状态  </span></span><br><span class="line">    _counter=widget.initValue;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"initState"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"build"</span>);</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: FlatButton(</span><br><span class="line">        child: Text(<span class="string">'<span class="subst">$_counter</span>'</span>),</span><br><span class="line">        <span class="comment">//点击后计数器自增  </span></span><br><span class="line">        onPressed:()=&gt;setState(()=&gt; ++_counter) ,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(CounterWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"didUpdateWidget"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> deactivate() &#123;</span><br><span class="line">    <span class="keyword">super</span>.deactivate();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"deactive"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"dispose"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> reassemble() &#123;</span><br><span class="line">    <span class="keyword">super</span>.reassemble();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"reassemble"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"didChangeDependencies"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们创建一个新路由，在新路由中，我们只显示一个<code>CounterWidget</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> CounterWidget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter ( 5436): initState</span><br><span class="line">I/flutter ( 5436): didChangeDependencies</span><br><span class="line">I/flutter ( 5436): build</span><br></pre></td></tr></table></figure>
<p>可以看到，在StatefulWidget插入到Widget树时首先<code>initState</code>方法会被调用。</p>
<p>然后我们点击⚡️按钮热重载，控制台输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter ( 5436): reassemble</span><br><span class="line">I/flutter ( 5436): didUpdateWidget</span><br><span class="line">I/flutter ( 5436): build</span><br></pre></td></tr></table></figure>
<p>可以看到此时<code>initState</code> 和<code>didChangeDependencies</code>都没有被调用，而此时<code>didUpdateWidget</code>被调用。</p>
<p>接下来，我们在widget树中移除<code>CounterWidget</code>，将路由<code>build</code>方法改为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">//移除计数器 </span></span><br><span class="line">  <span class="comment">//return CounterWidget();</span></span><br><span class="line">  <span class="comment">//随便返回一个Text()</span></span><br><span class="line">  <span class="keyword">return</span> Text(<span class="string">"xxx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后热重载，日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I/flutter ( 5436): reassemble</span><br><span class="line">I/flutter ( 5436): deactive</span><br><span class="line">I/flutter ( 5436): dispose</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在<code>CounterWidget</code>从widget树中移除时，<code>deactive</code>和<code>dispose</code>会依次被调用。</p>
<p>下面我们来看看各个回调函数：</p>
<ul>
<li><code>initState</code>：当Widget第一次插入到Widget树时会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用<code>BuildContext.inheritFromWidgetOfExactType</code>（该方法用于在Widget树上获取离当前widget最近的一个父级<code>InheritFromWidget</code>，关于<code>InheritedWidget</code>我们将在后面章节介绍），原因是在初始化完成后，Widget树中的<code>InheritFromWidget</code>也可能会发生变化，所以正确的做法应该在在<code>build（）</code>方法或<code>didChangeDependencies()</code>中调用它。</li>
<li><code>didChangeDependencies()</code>：当State对象的依赖发生变化时会被调用；例如：在之前<code>build()</code> 中包含了一个<code>InheritedWidget</code>，然后在之后的<code>build()</code> 中<code>InheritedWidget</code>发生了变化，那么此时<code>InheritedWidget</code>的子widget的<code>didChangeDependencies()</code>回调都会被调用。典型的场景是当系统语言Locale或应用主题改变时，Flutter framework会通知widget调用此回调。</li>
<li><p><code>build()</code>：此回调读者现在应该已经相当熟悉了，它主要是用于构建Widget子树的，会在如下场景被调用：</p>
<ol>
<li>在调用<code>initState()</code>之后。</li>
<li>在调用<code>didUpdateWidget()</code>之后。</li>
<li>在调用<code>setState()</code>之后。</li>
<li>在调用<code>didChangeDependencies()</code>之后。</li>
<li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。</li>
</ol>
</li>
<li><code>reassemble()</code>：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</li>
<li><code>didUpdateWidget()</code>：在widget重新构建时，Flutter framework会调用<code>Widget.canUpdate</code>来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果<code>Widget.canUpdate</code>返回<code>true</code>则会调用此回调。正如之前所述，<code>Widget.canUpdate</code>会在新旧widget的key和runtimeType同时相等时会返回true，也就是说在在新旧widget的key和runtimeType同时相等时<code>didUpdateWidget()</code>就会被调用。</li>
<li><code>deactivate()</code>：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用<code>dispose()</code>方法。</li>
<li><code>dispose()</code>：当State对象从树中被永久移除时调用；通常在此回调中释放资源。</li>
</ul>
<blockquote>
<p>todo: 这里缺一张生命周期图</p>
</blockquote>
<p>注意：在继承StatefulWidget重写其方法时，对于包含@mustCallSuper标注的父类方法，都要在子类方法中先调用父类方法。</p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><p>响应式的编程框架中都会有一个永恒的主题——“状态管理”，无论是在React/Vue（两者都是支持响应式编程的web开发框架）还是Flutter，他们讨论的问题和解决的思想都是一致的。所以，如果你对React/Vue的状态管理有了解，可以跳过本节。言归正传，我们想一个问题，stateful widget的状态应该被谁管理？widget本身？父widget？都会？还是另一个对象？答案是取决于实际情况！以下是管理状态的最常见的方法：</p>
<ul>
<li>Widget管理自己的state。</li>
<li>父widget管理子widget状态。</li>
<li>混合管理（父widget和子widget都管理状态）。</li>
</ul>
<p>如何决定使用哪种管理方法？以下原则可以帮助你决定：</p>
<ul>
<li>如果状态是用户数据，如复选框的选中状态、滑块的位置，则该状态最好由父widget管理。</li>
<li>如果状态是有关界面外观效果的，例如颜色、动画，那么状态最好由widget本身来管理。</li>
<li>如果某一个状态是不同widget共享的则最好由它们共同的父widget管理。</li>
</ul>
<p>在widget内部管理状态封装性会好一些，而在父widget中管理会比较灵活。有些时候，如果不确定到底该怎么管理状态，那么推荐的首选是在父widget中管理（灵活会显得更重要一些）。</p>
<p>接下来，我们将通过创建三个简单示例TapboxA、TapboxB和TapboxC来说明管理状态的不同方式。 这些例子功能是相似的 ——创建一个盒子，当点击它时，盒子背景会在绿色与灰色之间切换。状态 <code>_active</code>确定颜色：绿色为<code>true</code> ，灰色为<code>false</code>。</p>
<p><img src="https://flutterchina.club/tutorials/interactive/images/tapbox-active-state.png" alt="a large green box with the text, &#39;Active&#39;"><img src="https://flutterchina.club/tutorials/interactive/images/tapbox-inactive-state.png" alt="a large grey box with the text, &#39;Inactive&#39;"></p>
<p>下面的例子将使用GestureDetector来识别点击事件，关于该GestureDetector的详细内容我们将在后面“事件处理”一章中介绍。</p>
<h3 id="Widget管理自身状态"><a href="#Widget管理自身状态" class="headerlink" title="Widget管理自身状态"></a>Widget管理自身状态</h3><p>_TapboxAState 类:</p>
<ul>
<li>管理TapboxA的状态。</li>
<li>定义<code>_active</code>：确定盒子的当前颜色的布尔值。</li>
<li>定义<code>_handleTap()</code>函数，该函数在点击该盒子时更新<code>_active</code>，并调用<code>setState()</code>更新UI。</li>
<li>实现widget的所有交互式行为。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TapboxA 管理自身状态.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- TapboxA ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxA</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TapboxA(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TapboxAState createState() =&gt; <span class="keyword">new</span> _TapboxAState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TapboxAState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TapboxA</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = !_active;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GestureDetector(</span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">        child: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Text(</span><br><span class="line">            _active ? <span class="string">'Active'</span> : <span class="string">'Inactive'</span>,</span><br><span class="line">            style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">200.0</span>,</span><br><span class="line">        decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">          color: _active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父widget管理子widget的state"><a href="#父widget管理子widget的state" class="headerlink" title="父widget管理子widget的state"></a>父widget管理子widget的state</h3><p>对于父widget来说，管理状态并告诉其子widget何时更新通常是比较好的方式。 例如，IconButton是一个图片按钮，但它是一个无状态的widget，因为我们认为父widget需要知道该按钮是否被点击来采取相应的处理。</p>
<p>在以下示例中，TapboxB通过回调将其状态导出到其父项。由于TapboxB不管理任何状态，因此它的父类为StatelessWidget。</p>
<p>ParentWidgetState 类:</p>
<ul>
<li>为TapboxB 管理<code>_active</code>状态.</li>
<li>实现<code>_handleTapboxChanged()</code>，当盒子被点击时调用的方法.</li>
<li>当状态改变时，调用<code>setState()</code>更新UI.</li>
</ul>
<p>TapboxB 类:</p>
<ul>
<li>继承<code>StatelessWidget</code>类，因为所有状态都由其父widget处理。</li>
<li>当检测到点击时，它会通知父widget。</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ParentWidget 为 TapboxB 管理状态.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------ ParentWidget --------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ParentWidgetState createState() =&gt; <span class="keyword">new</span> _ParentWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ParentWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ParentWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapboxChanged(<span class="built_in">bool</span> newValue) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">      child: <span class="keyword">new</span> TapboxB(</span><br><span class="line">        active: _active,</span><br><span class="line">        onChanged: _handleTapboxChanged,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------- TapboxB ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  TapboxB(&#123;Key key, <span class="keyword">this</span>.active: <span class="keyword">false</span>, <span class="meta">@required</span> <span class="keyword">this</span>.onChanged&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> active;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="built_in">bool</span>&gt; onChanged;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    onChanged(!active);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GestureDetector(</span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">        child: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Text(</span><br><span class="line">            active ? <span class="string">'Active'</span> : <span class="string">'Inactive'</span>,</span><br><span class="line">            style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.white),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">200.0</span>,</span><br><span class="line">        decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">          color: active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合管理"><a href="#混合管理" class="headerlink" title="混合管理"></a>混合管理</h3><p>对于一些widget来说，混合管理的方式非常有用。在这种情况下，widget自身管理一些内部状态，而父widget管理一些其他外部状态。</p>
<p>在下面TapboxC示例中，按下时，盒子的周围会出现一个深绿色的边框。抬起时，边框消失；点击生效，盒子的颜色改变。 TapboxC将其<code>_active</code>状态导出到其父widget中，但在内部管理其<code>_highlight</code>状态。这个例子有两个状态对象<code>_ParentWidgetState</code>和<code>_TapboxCState</code>。</p>
<p>_ParentWidgetStateC 对象:</p>
<ul>
<li>管理<code>_active</code> 状态。</li>
<li>实现 <code>_handleTapboxChanged()</code> ，当盒子被点击时调用。</li>
<li>当点击盒子并且<code>_active</code>状态改变时调用<code>setState()</code>更新UI。</li>
</ul>
<p>_TapboxCState 对象:</p>
<ul>
<li>管理<code>_highlight</code> state。</li>
<li><code>GestureDetector</code>监听所有tap事件。当用户点下时，它添加高亮（深绿色边框）；当用户释放时，会移除高亮。</li>
<li>当按下、抬起、或者取消点击时更新<code>_highlight</code>状态，调用<code>setState()</code>更新UI。</li>
<li>当点击时，将状态的改变传递给父widget.</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------- ParentWidget ----------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentWidgetC</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ParentWidgetCState createState() =&gt; <span class="keyword">new</span> _ParentWidgetCState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ParentWidgetCState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ParentWidgetC</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _active = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapboxChanged(<span class="built_in">bool</span> newValue) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _active = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">      child: <span class="keyword">new</span> TapboxC(</span><br><span class="line">        active: _active,</span><br><span class="line">        onChanged: _handleTapboxChanged,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------- TapboxC ------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TapboxC</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  TapboxC(&#123;Key key, <span class="keyword">this</span>.active: <span class="keyword">false</span>, <span class="meta">@required</span> <span class="keyword">this</span>.onChanged&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> active;</span><br><span class="line">  <span class="keyword">final</span> ValueChanged&lt;<span class="built_in">bool</span>&gt; onChanged;</span><br><span class="line"></span><br><span class="line">  _TapboxCState createState() =&gt; <span class="keyword">new</span> _TapboxCState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TapboxCState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TapboxC</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">bool</span> _highlight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapDown(TapDownDetails details) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _highlight = <span class="keyword">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapUp(TapUpDetails details) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _highlight = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTapCancel() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _highlight = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handleTap() &#123;</span><br><span class="line">    widget.onChanged(!widget.active);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">// 在按下时添加绿色边框，当抬起时，取消高亮  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> GestureDetector(</span><br><span class="line">      onTapDown: _handleTapDown, <span class="comment">// 处理按下事件</span></span><br><span class="line">      onTapUp: _handleTapUp, <span class="comment">// 处理抬起事件</span></span><br><span class="line">      onTap: _handleTap,</span><br><span class="line">      onTapCancel: _handleTapCancel,</span><br><span class="line">      child: <span class="keyword">new</span> Container(</span><br><span class="line">        child: <span class="keyword">new</span> Center(</span><br><span class="line">          child: <span class="keyword">new</span> Text(widget.active ? <span class="string">'Active'</span> : <span class="string">'Inactive'</span>,</span><br><span class="line">              style: <span class="keyword">new</span> TextStyle(fontSize: <span class="number">32.0</span>, color: Colors.white)),</span><br><span class="line">        ),</span><br><span class="line">        width: <span class="number">200.0</span>,</span><br><span class="line">        height: <span class="number">200.0</span>,</span><br><span class="line">        decoration: <span class="keyword">new</span> BoxDecoration(</span><br><span class="line">          color: widget.active ? Colors.lightGreen[<span class="number">700</span>] : Colors.grey[<span class="number">600</span>],</span><br><span class="line">          border: _highlight</span><br><span class="line">              ? <span class="keyword">new</span> Border.all(</span><br><span class="line">                  color: Colors.teal[<span class="number">700</span>],</span><br><span class="line">                  width: <span class="number">10.0</span>,</span><br><span class="line">                )</span><br><span class="line">              : <span class="keyword">null</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种实现可能会将高亮状态导出到父widget，同时保持<code>_active</code>状态为内部，但如果你要将该TapBox给其它人使用，可能没有什么意义。 开发人员只会关心该框是否处于Active状态，而不在乎高亮显示是如何管理的，所以应该让TapBox内部处理这些细节。</p>
<h3 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h3><p>当应用中包括一些跨widget（甚至跨路由）的状态需要同步时，上面介绍的方法很难胜任了。比如，我们有一个设置页，里面可以设置应用语言，但是我们为了让设置实时生效，我们期望在语言状态发生改变时，我们的APP Widget能够重新build一下，但我们的APP Widget和设置页并不在一起。正确的做法是通过一个全局状态管理器来处理这种“相距较远”的widget之间的通信。目前主要有两种办法：</p>
<ol>
<li>实现一个全局的事件总线，将语言状态改变对应为一个事件，然后在APP Widget所在的父widget<code>initState</code> 方法中订阅语言改变的事件，当用户在设置页切换语言后，我们触发语言改变事件，然后APP Widget那边就会收到通知，然后重新<code>build</code>一下即可。</li>
<li>使用redux这样的全局状态包，读者可以在pub上查看其详细信息。</li>
</ol>
<p>本书后面<strong>事件处理</strong>一章中会实现一个全局事件总线。</p>
<h2 id="Flutter-widget库介绍"><a href="#Flutter-widget库介绍" class="headerlink" title="Flutter widget库介绍"></a>Flutter widget库介绍</h2><p>Flutter提供了一套丰富、强大的基础widget，在基础widget库之上Flutter又提供了一套Material风格（Android默认的视觉风格）和一套Cupertino风格（iOS视觉风格）的widget库。要使用基础widget库，需要先导入：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/widgets.dart'</span>;</span><br></pre></td></tr></table></figure>
<p>下面我们介绍一下常用的widget。</p>
<h3 id="基础widget"><a href="#基础widget" class="headerlink" title="基础widget"></a>基础widget</h3><ul>
<li><a href="https://docs.flutter.io/flutter/widgets/Text-class.html" target="_blank" rel="noopener"><code>Text</code></a>：该 widget 可让您创建一个带格式的文本。</li>
<li><a href="https://docs.flutter.io/flutter/widgets/Row-class.html" target="_blank" rel="noopener"><code>Row</code></a>、 <a href="https://docs.flutter.io/flutter/widgets/Column-class.html" target="_blank" rel="noopener"><code>Column</code></a>： 这些具有弹性空间的布局类Widget可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于web开发中的Flexbox布局模型。</li>
<li><a href="https://docs.flutter.io/flutter/widgets/Stack-class.html" target="_blank" rel="noopener"><code>Stack</code></a>： 取代线性布局 (译者语：和Android中的FrameLayout相似)，<a href="https://docs.flutter.io/flutter/widgets/Stack-class.html" target="_blank" rel="noopener"><code>Stack</code></a>允许子 widget 堆叠， 你可以使用 <a href="https://docs.flutter.io/flutter/widgets/Positioned-class.html" target="_blank" rel="noopener"><code>Positioned</code></a> 来定位他们相对于<code>Stack</code>的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。</li>
<li><a href="https://docs.flutter.io/flutter/widgets/Container-class.html" target="_blank" rel="noopener"><code>Container</code></a>： <a href="https://docs.flutter.io/flutter/widgets/Container-class.html" target="_blank" rel="noopener"><code>Container</code></a> 可让您创建矩形视觉元素。container 可以装饰一个<a href="https://docs.flutter.io/flutter/painting/BoxDecoration-class.html" target="_blank" rel="noopener"><code>BoxDecoration</code></a>, 如 background、一个边框、或者一个阴影。 <a href="https://docs.flutter.io/flutter/widgets/Container-class.html" target="_blank" rel="noopener"><code>Container</code></a> 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， <a href="https://docs.flutter.io/flutter/widgets/Container-class.html" target="_blank" rel="noopener"><code>Container</code></a>可以使用矩阵在三维空间中对其进行变换。</li>
</ul>
<h3 id="Material-widget"><a href="#Material-widget" class="headerlink" title="Material widget"></a>Material widget</h3><p>Flutter提供了一套丰富的Material widget，可帮助您构建遵循Material Design的应用程序。Material应用程序以<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html" target="_blank" rel="noopener"><code>MaterialApp</code></a> widget开始， 该widget在应用程序的根部创建了一些有用的widget，比如一个Theme，它配置了应用的主题。 是否使用<a href="https://docs.flutter.io/flutter/material/MaterialApp-class.html" target="_blank" rel="noopener"><code>MaterialApp</code></a>完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个Material widget了，如：<code>Scaffold</code>、<code>AppBar</code>、<code>FlatButton</code>等。要使用Material widget，需要先引入它：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Cupertino-widget"><a href="#Cupertino-widget" class="headerlink" title="Cupertino widget"></a>Cupertino widget</h3><p>Flutter也提供了一套丰富的Cupertino风格的widget，尽管目前还没有Material widget那么丰富，但也在不断的完善中。值得一提的是在Material widget库中，有一些widget可以根据实际运行平台来切换表现风格，比如<code>MaterialPageRoute</code>，在路由切换时，如果是Android系统，它将会使用Android系统默认的页面切换动画(从底向上)，如果是iOS系统时，它会使用iOS系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino widget的示例，我们实现一个简单的Cupertino页面：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入cupertino widget库</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/cupertino.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CupertinoTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CupertinoPageScaffold(</span><br><span class="line">      navigationBar: CupertinoNavigationBar(</span><br><span class="line">        middle: Text(<span class="string">"Cupertino Demo"</span>),</span><br><span class="line">      ),</span><br><span class="line">      child: Center(</span><br><span class="line">        child: CupertinoButton(</span><br><span class="line">            color: CupertinoColors.activeBlue,</span><br><span class="line">            child: Text(<span class="string">"Press"</span>),</span><br><span class="line">            onPressed: () &#123;&#125;</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是在iPhoneX上页面效果截图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action@1.0/docs/imgs/image-20180824181958838.png" alt="image-20180824181958838"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flutter提供了丰富的widget，在实际的开发中你可以随意使用它们，不要怕引入过多widget库会让你的应用安装包变大，这不是web开发，dart在编译时只会编译你使用了的代码。由于Material和Cupertino都是在基础widget库之上的，所以如果你的应用中引入了这两者之一，则不需要再引入<code>flutter/widgets.dart</code>了，因为它们内部已经引入过了。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/flutter/" rel="tag"># flutter</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/11/flutter-chapter2-06thread_model_and_error_report/" rel="next" title="第二章 - 06资源管理">
                <i class="fa fa-chevron-left"></i> 第二章 - 06资源管理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/13/flutter-chapter3-02text/" rel="prev" title="第三章 - 02文本及样式">
                第三章 - 02文本及样式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="st">
            
              <p class="site-author-name" itemprop="name">st</p>
              <div class="site-description motion-element" itemprop="description">人生滋味，情最浓；世间繁华，淡最真。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/STShenZhaoliang" title="GitHub &rarr; https://github.com/STShenZhaoliang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Widget简介"><span class="nav-number">1.</span> <span class="nav-text">Widget简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Widget与Element"><span class="nav-number">1.2.</span> <span class="nav-text">Widget与Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要接口"><span class="nav-number">1.3.</span> <span class="nav-text">主要接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stateless-Widget"><span class="nav-number">2.</span> <span class="nav-text">Stateless Widget</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stateful-Widget"><span class="nav-number">3.</span> <span class="nav-text">Stateful Widget</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#State"><span class="nav-number">3.1.</span> <span class="nav-text">State</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#State生命周期"><span class="nav-number">3.1.1.</span> <span class="nav-text">State生命周期</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#状态管理"><span class="nav-number">4.</span> <span class="nav-text">状态管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Widget管理自身状态"><span class="nav-number">4.1.</span> <span class="nav-text">Widget管理自身状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#父widget管理子widget的state"><span class="nav-number">4.2.</span> <span class="nav-text">父widget管理子widget的state</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合管理"><span class="nav-number">4.3.</span> <span class="nav-text">混合管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#全局状态管理"><span class="nav-number">4.4.</span> <span class="nav-text">全局状态管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flutter-widget库介绍"><span class="nav-number">5.</span> <span class="nav-text">Flutter widget库介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础widget"><span class="nav-number">5.1.</span> <span class="nav-text">基础widget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Material-widget"><span class="nav-number">5.2.</span> <span class="nav-text">Material widget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cupertino-widget"><span class="nav-number">5.3.</span> <span class="nav-text">Cupertino widget</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">5.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">st</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
